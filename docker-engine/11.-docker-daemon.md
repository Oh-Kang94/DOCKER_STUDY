# 11. Docker Daemon

## 1. docker의 구조

docker의 구조는 크게 두가지이다. (클라이언트의 docker(docker), 서버의 docker(dockerd))

CLI를 제공하는게 도커 클라이언트 이다. `docker ~`로 시작하는 걸 쓰면 그게 도커 클라이언트를 쓰는것이다.
docker daemon은 /var/run/docker.sock을 이용한다.

## 2. docker 데몬 설정

### 2-1. docker 데몬제어 `-H`

`-H` 옵션은 도커 데몬의 API를 사용할 수 있는 방법을 추가한다.
추가하게 되면, RESTFUL API의 성격을 띄게 되며, 소켓을 지정하지 않으면, 도커 클라이언트는 더이상 사용할 수 없게 된다.

그러므로,

```bash
dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:${port} --tls=false
```

`tls` 인증은 보안을 위해서라도, 항상 적용하는게 좋다.

### 2-2. docker daemon에 보안 적용 `--tlsverify`

도커를 설치하면 보안 연결이 안되어있다.

1.  서버 측 파일 생성

    1. 인증서에 사용될 키를 생성
       **설명**

    - CA(인증기관)에서 사용할 루트 개인키 생성
    - `-aes256`: 키 파일 암호화
    - `4096`: 4096비트 RSA 키
    - 비밀번호는 이후 서명 과정에서 다시 필요함

      ```bash
      ❯ openssl genrsa -aes256 -out ca-key-rootPw.pem 4096
      Enter PEM pass phrase:
      Verifying - Enter PEM pass phrase:
      ```

    2. 공용키를 생성
       **설명**

    - 루트 개인키로 자체 서명 CA 인증서 생성
    - `-x509`: CSR 없이 바로 인증서 생성
    - `-days 10000`: 약 27년 유효
    - 출력: `ca-key-public.pem` (CA 공개 인증서)

    ```bash
    ❯ openssl req -new -x509 -days 10000 -key ca-key-rootPw.pem -sha256 -out ca-key-public.pem
     Enter pass phrase for ca-key-rootPw.pem:
     You are about to be asked to enter information that will be incorporated
     into your certificate request.
     What you are about to enter is what is called a Distinguished Name or a DN.
     There are quite a few fields but you can leave some blank
     For some fields there will be a default value,
     If you enter '.', the field will be left blank.
     -----
     Country Name (2 letter code) [AU]:
     State or Province Name (full name) [Some-State]:
     Locality Name (eg, city) []:
     Organization Name (eg, company) [Internet Widgits Pty Ltd]:
     Organizational Unit Name (eg, section) []:
     Common Name (e.g. server FQDN or YOUR name) []:
     Email Address []:
    ```

    3. 서버 측에서 사용될 키를 생성
       **설명**

    - 서버 전용 개인키 생성
    - 추후 CSR 발급에 사용됨

    ```bash
    openssl genrsa -out server-key.pem 4096
    ```

    4. 서버측에서 사용될 인증 요청서 파일을 생성
       **설명**

    - 서버 인증서 발급용 CSR 생성
    - `-subj` 로 입력값 자동 설정

    ```bash
    openssl req -subj "/CN=192.168.64.3" -sha256 -new -key server-key.pem -out server.csr
    ```

    5. 접속에 사용될 IP주소를 extfile.cnf 파일로 저장
       **설명**

    - SAN(Subject Alternative Name) 정의
    - 인증서 검증 시 필수 항목으로, 서버가 해당 IP에서 TLS 인증 통과 가능

    ```extfile.cnf
    	subjectAltName = IP:192.168.64.3,IP:127.0.0.1
    ```

    6. 서버측의 인증서 파일을 생성
       **설명**

    - CSR을 CA가 서명해 서버 인증서 발급
    - `-CAcreateserial` : CA용 serial 파일 생성
    - 출력: `server-cert.pem` (서버 인증서)

    ```bash
    	❯ openssl x509 -req -days 10000 -sha256 -in server.csr \
    			-CA ca-key-public.pem -CAkey ca-key-rootPw.pem \
    			-CAcreateserial -out server-cert.pem -extfile extfile.cnf
    	Certificate request self-signature ok
    	subject=CN = 192.168.64.3
    	Enter pass phrase for ca-key-rootPw.pem:
    ```

    ISSUE: #2 집가서, 데몬의 보안 설정 하는걸 추가해야한다.

## 3. Storage 설정 `--storage-driver`

Storage Driver의 기본 설정은 `overlay2`이다.

```bash
docker info | grep "Storage Driver"
```

하지만, `zfs`를 사용하게 하고 싶으면,

```bash
dockerd --storage-driver=zfs
```

이렇게 바꾸면 된다.

- overlay2, Btrfs, zfs 비교

| 항목                               | **overlay2**                             | **Btrfs**                                    | **ZFS**                                            |
| ---------------------------------- | ---------------------------------------- | -------------------------------------------- | -------------------------------------------------- |
| **지원 OS**                        | 대부분의 현대 Linux 배포판에서 기본 지원 | openSUSE, Ubuntu 등 Btrfs 지원 시스템        | ZFS 지원 환경 (Ubuntu, Debian, Proxmox 등)         |
| **도커 기본값 여부**               | **예 (가장 일반적)**                     | 아니오                                       | 아니오                                             |
| **성능 (일반적 로드)**             | **빠름 (가벼운 Copy-on-write)**          | 좋음 (COW 기반, 메타데이터 헤비)             | 매우 빠름 (ARC 캐시 기반)                          |
| **대규모 이미지/레이어 처리 성능** | 매우 우수                                | 중간 (메타데이터 병목 가능)                  | 우수                                               |
| **Copy-on-Write 효율**             | 중간                                     | 좋음                                         | **매우 좋음**                                      |
| **스냅샷 기능**                    | 기본적으로 없음 (파일 시스템 단위 X)     | 지원 (파일 시스템 스냅샷)                    | **강력한 스냅샷 & 롤백 기능 제공**                 |
| **Checksum (데이터 무결성)**       | 없음                                     | 있음                                         | **전체 데이터 & 메타데이터 체크섬 제공**           |
| **RAID 기능**                      | 없음                                     | 기본 X(하지만 Btrfs 자체 기능으로 RAID 가능) | **ZFS 기본 제공(ZRAID)**                           |
| **디스크 공간 효율성**             | 가장 효율적                              | 중간                                         | 중간(메타데이터 오버헤드 존재)                     |
| **관리 편의성**                    | 매우 쉬움 (기본값)                       | 비교적 쉬움                                  | 설정이 복잡 (튜닝 필요)                            |
| **대규모 컨테이너 환경 적합성**    | **가장 안정적**                          | 대규모 환경에서는 권장 안 함                 | 고성능 스토리지 필요 시 적합                       |
| **안정성**                         | 매우 높음                                | 문제 발생 케이스 존재(Btrfs 초기 문제 이슈)  | 매우 높음 (엔터프라이즈급)                         |
| **주 사용 사례**                   | 대부분의 일반 Docker 환경                | 스냅샷 기반 개발 환경                        | 고가용성, 엔터프라이즈 저장소, 백업/롤백 필요 환경 |

### 기본 디렉토리 지정

default 는 `var/lib/docker/{driver name}`으로 지정이 된다.

```bash
dockerd --data-root /DATA/docker
```

이런식으로 기본 컨테이너 및 이미지 등등 도커관련 파일 저장소를 지정할 수 있다.

하지만, **각 스토리지 드라이버를 쓸때는 각각 설정이 필요하다.**

### 스토리지 드라이버의 원리

기본적으로 수정이 아니라, CoW (Copy on Write)를 이용해서 한다.
과정은

1. 쓰기요청을 한다.
2. 원본 파일을 읽어 들인 뒤 스냅샷 공간으로 복사를 한다.
3. 실제 쓰기 요청은 복사된 파일에 수행을 한다.

이렇게 각 이미지는 레이어를 쌓아서 진행을 한다.

### btrfs 드라이버 사용하기

- **SSD 최적화**, 데이터 압축등 다양한 기능을 제공

하지만, 파일 시스템 구축이 필요하며, 그 이전에는 도커에서 활용할 수 없다.

1. 도커 데몬을 정지
2. btrfs 스토리지 풀을 생성

```bash
mkfs.btrfs -f /dev/btrfs
```

3. 도커가 이미 설치 되어서, `/var/lib/docker`가 비어있어야한다. 백업 후, 디렉토리 삭제 후 재생성이 추천
4. 호스트 종료후에도, 마운트하기 위해 `/etc/fstab`에 관련 내용을 추가

```/etc/fstab
/dev/btrfs /var/lib/docker btrfs defaults 0 0
```

5. `mount -a`로 파일 시스템을 마운트
6. btrfs 파일 시스템을 마운트 했다면, `--storage-driver=btrfs` 를 추가 후, `service docker restart`를 실행하여, 확인

# 12. 도커 데몬 모니터링

## 1. 도커 데몬 디버그 모드

```bash
dockerd -D
```

이지만, 사용은 ubuntu는 `journalctl -u docker` 로 확인 가능

## 2. `events`, `stats`, `system df` 명령어

### 1. events

도커 데몬에 어떤 일이 일어나고 있는지 스트림 로그로 보여준다.

```bash
docker events
2025-12-11T11:40:15.170024614+09:00 container kill d394ad4ab4f798429b72302daf5bfcbb2176905c3d047e81da8ebc778fa8d93e (description=Eclipse Mosquitto MQTT Broker, image=eclipse-mosquitto:2.0.20, maintainer=Roger Light <roger@atchoo.org>, name=trusting_hoover, signal=9)
2025-12-11T11:40:15.236177123+09:00 network disconnect ebe5d78ff823450b35aa8b826375d0bfbc7c432e3ac29daca114306604bc9175 (container=d394ad4ab4f798429b72302daf5bfcbb2176905c3d047e81da8ebc778fa8d93e, name=bridge, type=bridge)
2025-12-11T11:40:15.247075624+09:00 volume unmount 2ead4dfb8acdf7dd0f33efa25916c0eb48258ab0e4484bd3d172ab1ab858ecf4 (container=d394ad4ab4f798429b72302daf5bfcbb2176905c3d047e81da8ebc778fa8d93e, driver=local)
2025-12-11T11:40:15.247107082+09:00 volume unmount f0b00233035729cc29e3950c9294a3a2b535c75f555f8a0d6cf6ecda3296cdc8 (container=d394ad4ab4f798429b72302daf5bfcbb2176905c3d047e81da8ebc778fa8d93e, driver=local)
2025-12-11T11:40:15.248710249+09:00 container die d394ad4ab4f798429b72302daf5bfcbb2176905c3d047e81da8ebc778fa8d93e (description=Eclipse Mosquitto MQTT Broker, execDuration=10, exitCode=137, image=eclipse-mosquitto:2.0.20, maintainer=Roger Light <roger@atchoo.org>, name=trusting_hoover)
2025-12-11T11:40:15.255215167+09:00 container destroy d394ad4ab4f798429b72302daf5bfcbb2176905c3d047e81da8ebc778fa8d93e (description=Eclipse Mosquitto MQTT Broker, image=eclipse-mosquitto:2.0.20, maintainer=Roger Light <roger@atchoo.org>, name=trusting_hoover)
```

- `--filter`를 통해서, 원하는 정보만 출력이 가능하다.
  container daemon event image label network scope type volume  
  이렇게 있다.
  이걸 활용하려면,

```bash
docker events --filter "type=image"
```

이렇게 명령 필요

### 2. stats

모든 컨테이너의 자원 사용량을 스트림으로 출력

```bash
> docker stats

CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O         PIDS
d0aed3ec23d0   gs_api            66.34%    1.769GiB / 62.67GiB   2.82%     4.2GB / 535MB     0B / 27GB         83
6978ddcd2b9f   gs_mqtt_dev       0.01%     3.422MiB / 100MiB     3.42%     35.5kB / 126B     3.77MB / 168kB    1
1af43f4f6e7e   gs_mediamtx_dev   126.24%   275.9MiB / 300MiB     91.98%    35.9kB / 126B     112GB / 0B        199
9bb3288854a5   gs_db_dev         0.00%     108.9MiB / 300MiB     36.30%    32.8kB / 126B     32.4MB / 32.8kB   9
fd9db99dce89   gs_db             0.00%     190.8MiB / 4GiB       4.66%     81.2MB / 123MB    47.3MB / 160MB    16
1ed321b5a639   gs_mqtt           1.68%     2.148MiB / 100MiB     2.15%     7.98GB / 1.74GB   2.08MB / 168kB    1
b35f853dbaa2   gs_mediamtx       98.23%    277MiB / 300MiB       92.32%    132MB / 7.36GB    11.3GB / 0B       198
```

### 3. CAdvisor
구글에서 만든 컨테이너 모니터링 도구이다. 

실행 방법
```bash
docker run \
  --volume=/:/rootfs:ro \
  --volume=/var/run:/var/run:ro \
  --volume=/sys:/sys:ro \
  --volume=/var/lib/docker/:/var/lib/docker:ro \
  --volume=/dev/disk/:/dev/disk:ro \
  --publish=8080:8080 \
  --detach=true \
  --name=cadvisor \
  --privileged \
  --device=/dev/kmsg \
  ghcr.io/google/cadvisor:v0.53.0 
```
docker official repo에 없으므로,
`ghcr.io/google/cadvisor:v0.53.0 `
이렇게 쳐야하고, 

[Github cadvisor](https://github.com/google/cadvisor)가서, 확인을 해야한다. 

**하지만, 단일 호스트만 모니터링한다는 한계로 인해서, 클러스터를 구축한 환경에서는 용도가 안맞는다.**
**나중에 쿠버네티스나, 스웜모드와 같은 오케스트레이션을 하게 되면, 프로메테우스등으로 구축하는게 일반적이다.**