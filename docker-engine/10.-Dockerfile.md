# 10. Dockerfile

## 1. 도커 파일 기본적인 명령어

```dockerfile
FROM ubuntu:24.04
# 작성자 표기 및 메타데이터 추가
LABEL maintainer="KangHyeon, Oh <okh19941994@naver.com>"
LABEL "purpose"="practice"

# 이미지를 만들기 위환 컨테이너 내부 명령어 실행
RUN apt-get update
RUN apt-get install apache2 -y
# 추가할 파일 옮기기
ADD test.html /var/www/html
# 명령어를 실행할 디렉토리 설정
WORKDIR /var/www/html

# 이미지 내부에서 행동할거
RUN ["/bin/bash", "-c", "echo hello >> test2.html"]

# 이미지에서 노출할 포트 지정
EXPOSE 80
CMD apachectl -DFOREGROUND
```

## 2. Dockerfile Build

- `t`로 설정을 해주는 편이 좋다.

```bash
    ❯ docker build -t myfirst:0.0 ./docker-images/apache/
```

## 4. Docker Port 확인

```bash
    ❯ docker port myserver
    80/tcp -> 0.0.0.0:32769
    80/tcp -> [::]:32769
```

## 5. Dockerignore

- 제외할 파일을 설정할 수 있다.

```dockerignore
*.html
!test*.html
```

## 6. Multi Stage Build

- Mono Stage

```bash
docker build -t go_helloworld .
REPOSITORY      TAG       IMAGE ID       CREATED          SIZE
go_helloworld   latest    5d80a3aa6337   2 minutes ago    1.3GB
```

- Multi Stage
  쓰면 이미지 용량을 많이 줄일 수 있다.
  \*\* alpine을 쓰면 초 경량 Linux image라 용량을 많이 줄일 수 있다.

```bash
docker build -t go_multi -f dockerfile-multi .
REPOSITORY      TAG       IMAGE ID       CREATED          SIZE
go_multi        latest    c24d6ba6215e   35 seconds ago   16.9MB
```

## 7. 기타 Docker 명령어

### 7.1. ENV

- 환경변수 지정을 dockerfile에서 할 수 있음

```dockerfile
FROM ubuntu:14.04
ENV test /home
WORKDIR $test
RUN ['touch', '$test/myFile' ]
```

- run 할 때 Override 가능

```bash
docker run -it \
--name env_test_override \
-e test=myValue \
myEnv:0.0.0 \
/bin/bash
```

### 7.2. VOLUME

Docker에서 컨테이너 내부 디렉토리를 볼륨으로 지정하면, 컨테이너 실행 시 Docker가 관리하는 저장 공간에 마운트됨.
호스트와 공유하거나 컨테이너 삭제 후에도 데이터 유지 가능.

- 익명 볼륨: VOLUME /path 형태로 지정 시, 호스트 경로를 명시하지 않고 Docker가 자동으로 볼륨 생성.
- 호스트 바인드 마운트: docker run -v /host/path:/container/path 형태로 지정하면 호스트 경로와 직접 동기화됨.
- **주의 사항** : Dockerfile에서 VOLUME 안에 미리 파일을 생성해도, 컨테이너 실행 시 새 볼륨이 마운트되면 기존 파일은 보장되지 않음.

```Dockerfile
FROM ubuntu:22.04

RUN mkdir /home/volume
RUN echo test >> /home/volume/testFile

VOLUME /home/volume
```

/home/volume은 컨테이너에서 볼륨으로 관리됨.
컨테이너 삭제 후에도 익명 볼륨은 남아 데이터 유지 가능.
호스트에서 직접 내용을 보고 싶으면 바인드 마운트를 사용해야 함:
`docker run -v ~/myHost/volume:/home/volume myImage`

### 7.3 ARG

- build 명령어를 실행 할때, 추가로 입력을 받아 Dockerfile 내부의 변수의 값을 지정
- `${my_arg}`이런식으로 표현이 됨

```dockerfile
FROM ubuntu:24.04
ARG my_arg
ARG my_arg_2=value2
RUN ["touch", "${my_arg_2}/myTouch"]
```

### 7.4 USER

Dockerfile에서 USER 명령어는 컨테이너 내에서 명령을 실행할 사용자 계정을 지정함.
기본적으로 컨테이너는 root 사용자로 실행되므로, 권한 문제나 보안 상 이유로 일반 사용자로 전환하는 것이 권장됨.
사용자 이름 또는 UID를 지정할 수 있으며, 필요하면 그룹(GROUP)도 함께 지정 가능.
예시 1: 간단한 사용자 지정

```dockerfile
FROM ubuntu:22.04

# 일반 사용자 생성
RUN useradd -ms /bin/bash myuser

# 생성한 사용자로 전환
USER myuser

# 이후 명령은 myuser 권한으로 실행
RUN echo "Hello from myuser" > /home/myuser/testfile
```

- `USER myuser` 이후 모든 명령(RUN, CMD, ENTRYPOINT 등)은 myuser 권한으로 실행됨.
- 루트 권한이 필요하면 다시 USER root로 전환 가능.
  예시 2: UID와 GID 지정

```dockerfile
FROM ubuntu:22.04

# 특정 UID, GID로 사용자 생성
RUN groupadd -g 1001 appgroup && \
 useradd -u 1001 -g appgroup -ms /bin/bash appuser

USER appuser
```

- 이렇게 하면 호스트와 UID/GID를 맞춰서 파일 권한 충돌을 방지 가능.

| 항목   | 설명                                                                                                   |
| ------ | ------------------------------------------------------------------------------------------------------ |
| USER   | 컨테이너 내 명령 실행 사용자 지정                                                                      |
| 기본값 | root                                                                                                   |
| 목적   | 권한 제한, 보안 강화, 파일 소유권 관리                                                                 |
| 주의   | USER 변경 후 일부 명령(RUN) 실행 시 권한 부족 문제 발생 가능 → 필요한 경우 sudo 사용하거나 root로 전환 |

### 7.5 Onbuild

- 빌드된 이미지를 기반으로 다른 이미지가 `Dockerfile`

```dockerfile
FROM alpine

RUN echo "This is on build Test"

ONBUILD RUN echo "on build" >> /on_build_file
```

```sh

docker build ./ -t onbuild_test:0.0.0

[+] Building 1.9s (6/6) FINISHED
 => [1/2] FROM docker.io/library
 => [2/2] RUN echo "This is on build Test"  0.1s
```

```bash
❯ docker run -it --rm onbuild_test:0.0.0
/ # ls
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var
```

이처럼, `ONBUILD`로 돌린 내용은 추가가 안된다.

하지만,

```dockerfile
FROM alpine

ONBUILD RUN echo "on build" >> /on_build_file

RUN echo "This is on build Test"
```

이건 잘 나오고 작성도 잘 된다.

- 사용 이유 : 템플릿처럼 반복되는 빌드 절차를 자동화 할때 사용
- 한번 만 실행 되므로, 부모의 자식 이미지에만 적용된다.

### 7.6 STOPSIGNAL

- 컨테이너가 정지될때 사용될 시스템 콜의 종류를 지정

* 보통은 SIGTERM이다.

```dockerfile
FROM ubuntu:22.04
STOPSIGNAL SIGKILL
```

### 7.7 HEALTH CHECK

- 이미지에서 생성된 컨테이너에서 동작하는 애플리케이션의 상태를 체크하도록 설정
- 컨테이너 내부에서 동작 중인 프로세스가 종료되지는 않았으나, 애플리케이션이 동작 안하는 상황을 방지

ex)

```dockerfile
FROM nginx
RUN apt-get update -y && apt-get install curl -y
# interval :  주기
HEALTHCHECK --interval=1m \
# 초과하면 실패로 간주하는 시간
--timeout=3s \ 
# 몇번이나 반복해서 할지, 3번이면 unhealthy로 간주
--retries=3 \ 
CMD curl -f http://localhost || exit 1
```

### 7.8 ADD, COPY
COPY는 로컬 호스트에서 컨텍스트를 읽어서 복사하는 역할을 한다.
ADD는 외부 URL이나, tar파일에서도 파일을 추가흔 점이 다르다.
`.tar`를 추가 할때는 압축을 해제하고 추가한다.
ADD는 사용을 권장하지 않는다. 왜냐하면, 상시성을 잃어버리기 때문에

### 7.9 ENTRYPOINT, CMD
ENTRYPOINT와 CMD의 차이점

- ENTRYPOINT: 컨테이너 시작 시 항상 실행되는 기본 명령을 지정하며, docker run의 인자는 ENTRYPOINT의 인수로 전달된다.
=> 그리고, 단 한번만 쓸 수 있다.
- CMD: 기본 인자 또는 기본 실행 명령을 지정하지만, docker run에서 사용자가 명령·인자를 입력하면 쉽게 대체(override) 된다.

JSON 배열 형식 vs 일반(Shell) 형식
1) JSON 배열 형식 (exec form)

  예: CMD ["python", "app.py"]
  쉘을 거치지 않고 직접 실행됨
  인자 파싱이 명확하고, ENTRYPOINT와 함께 사용 시 예측 가능·권장 방식
  
2) 일반 문자열 형식 (shell form)

  예: CMD python app.py
  내부적으로 /bin/sh -c 를 통해 쉘에서 실행됨
  변수 확장 · 파이프 등 쉘 기능 사용 가능
  ENTRYPOINT와 함께 쓰면 동작이 복잡해져 비권장